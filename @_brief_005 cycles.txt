================================================================================

00_04 Категории циклов

    Конечные циклы (исчисляемые) - заранее известно число итераций (песочные часы)
    
    Условные циклы - циклы с незвестным заранее числом итераций (система Земля - Солнце)
    
    В различных языках реализовано несколько видов циклов

================================================================================

00_15 Циклические конструкции Python

    В python реаливано 2 циклические конструкции (while, for)
    
    while - условный цикл
    ожидат объект либо выражение, которое возвращет объект и неявным образом осущ. проверку на истинность
    если истинность объекта == True, то выполняется код в теле цикла, после возвразается к заголовку
    и снова проверяет переданный ему объект
    
    while True:
        print('начало')
      # выполняемый код
        print('конец')

    while a < 10:
        print('начало')
      # выполняемый код
        print('конец')
    
    >>> while a < 10:
    ...     a += 1
    ...     print(a, end=' - ')
    ...
    1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - >>>
    
    while False: цикл не выполняется
    
    кроме проверки заголовка цикла, можем явно указать на выход из цикла
    
00_33 - break - прерывает текущую итерацию и выходит из цикла
    
    while True: - проверка
        print('начало тела') - инструкция выполняется
        break                - явно указываем на выход
        print('конец тела')  - инструкция не выполняется
    print('конец цикла')   

    >>> while True:
    ...     command = input(' > ')
    ...     if command == 'quit':
    ...             break
    ...     print(command*2)
    ...
     > look
    looklook
     > stop
    stopstop
     > quit
    >>>
    
  ! В заголовке прописывается условие входа в тело цикла
  ! В теле прописывается условие выхода из цикла
    

00_50 - continue - текущая итерация прерывается, переходит к следующей итерации (не выходит из цикла)

00_52 У циклических конструкций есть опциональный блок else

    cnt = 10
    
    while cnt > 0:
        cnt -= 1
    else:
        print('цикл завершен корректно') - дойдем до этой строки
        
    
    while cnt > 0:
        cnt -= 1
        if not cnt % 7:
            break
    else:
        print('цикл завершен корректно') - не дойдем до этой строки.
    
  ! корректным считается завершение, которое не было досрочно прервано.

=======================================================================================

01_05 - Перехват исключений

    Ошибки - бывают 2х видов (синтаксические и логические)
    
    Когда возникает синтаксическая ошибка, то наш код не будет выполнен
    Синтаксические ошибки отлавливаются интерпритаторим перед выполнением кода.
    
    Логические ошибки происходят в процессе выполнения кода (определено 49 видов логических ошибок)
    Прим. - ValueError, NameError, ZerroDivisionError - объекты исключений (exceptions)
    
    По умолчанию exception - останавливает код в момент логической ошибки
    
01_12 - Конструкция перехвата исключений.

    Перехват исключений нужен для управления (не остановкой) нашего кода.
    
    try: (перев. - попытка)
        ... помещаем инструкцию, которая по задумке должна быть выполнена,
        но при какихто обстоятельствах может возникнуть ошибка.
    except: (перев. - кроме)
        ... блок выполняется в случае получения прогнозируемой ошибки в try,
        после чего выполняется блок finally
    else:
        ... блок выполняется если не возникает ошибки в блоке try
    finally: (перев. - завершение)
        ... выполняется в любом случае и когда исключение возникает и 
        когда исключение не возникает
        
    Варианты цепочек выполнения:
    
        try(корректно) - else - finally
        try(ошибка) - except - finally
        
    Конструкция try - except по умолчанию состоит из 4 блоков.
    
    Примеры использования
    
    >>> try:
    ...     print(a/0)
    ... except NameError:
    ...     print('перехват NameError')
    ...
    перехват NameError
    >>>
    
    >>> a = 10
    >>> try:
    ...     print(a / 0)
    ... except NameError:
    ...     print('перехват NameError')
    ... except ZeroDivisionError:
    ...     print('перехват ZeroDivisionError')
    ...
    перехват ZeroDivisionError
    >>>
      
  ! Если в блоке try возникает исключение, то блок try приостанавливается
  ! Очень не желательно перехватывать все искючения
  ! Перехватываются только ожидаемые исключения
  
=======================================================================================

02_08 - цикл for

    for работает только с итерируемыми объектами.
    
    text = 'Python is supercool!'
    total = 0
    
    for char in text:
        if char == ' ':
            total += 1
            
    print(f'в строке {total+1} слов(а)')
  
  
    >>> fruits = ('apple', 'banana')
    >>> indexes = (0, 1)
    >>> for i in indexes:
    ...     print(fruits[i])
    ...
    apple
    banana
    >>>

=======================================================================================
    
02_28 - range() - встроенная функция (чаще всего используется для генерации последовательности индексов)

    Перадаем аргументы 3 разными способами (начало последовательности, конец последовательности (не включая), шаг)
    Функция range возвращает - объект собственного типа class 'range'
    
    >>> list(range(3))
    [0, 1, 2]
    >>> list(range(5))
    [0, 1, 2, 3, 4]
    >>> list(range(10))
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>>
    
    >>> list(range(2, 10))
    [2, 3, 4, 5, 6, 7, 8, 9]
    >>> list(range(-5, 5))
    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
    
    >>> list(range(-5))
    []

    >>> list(range(5, 0, -1))
    [5, 4, 3, 2, 1]
    >>> list(range(-4, 5, 2))
    [-4, -2, 0, 2, 4]
    >>> list(range(-4, 6, 2))
    [-4, -2, 0, 2, 4]
    
    
=======================================================================================

02_41 - for + range

    for i in renge(len(fruits)):
        print(fruits[i], end=' ')
    
=======================================================================================

02_45 - enumerate
    
    Функция enumerate возвращает - объект собственного типа class 'enumerate'
    
    >>> for elem in enumerate('text'):
    ...     print(elem)
    ...
    (0, 't')
    (1, 'e')
    (2, 'x')
    (3, 't')

=======================================================================================

02_48 - распаковка

    a, b, c, = [1, 2, 3, 4]
    
    >>> a, b, c, d = [1, 2, 3, 4]
    >>> a
    1
    >>> b
    2
    >>> c
    3
    >>> d
    4
    
=======================================================================================

02_50 - распаковка + enumerate   
    
    >>> for i, char in enumerate('text'):
    ...     print(f'{i=} {char=}')
    ...
    i=0 char='t'
    i=1 char='e'
    i=2 char='x'
    i=3 char='t'
    >>>

!!! 

    for i, fruit in enumerate(fruits):
        fruits[i] = fruit.capitalaze()
        
========================================================================================

Другое полезное

^C - прервать текущий процесс в командной строке

! all, any --- !!!

print(f'{cnt}') - строковое представление
print(f'{cnt=}') - тоже самое, что и print(f'cnt = {cnt}')