===========================================================================

00_01 - анонимные функции lambda (class function)

  ! для ситуаций создания объекта для одноразового использования
  ! вычисляется на месте
  ! допускается передача строго ключевых и строго позиционных аргументов
  
    Объявление с помощью ключевого слова lambda
    
    nums = [1, 2, 3]
    lambda: sum(nums) ** 0.5
    
  ! объявление def - инструкция, в lambda - выражение (возвращает объект)
  ! плохая практика сохрянаять lambda в переменную
  
    func_1 = lambda: 'вызов анонимной функции'
    func_2 = lambda num1, num2: num1 * num2
    
  # >>> f_1 = lambda num1, num2: num1 * num2
  # >>> f_1
  # <function <lambda> at 0x000001360AF1B1A0>
  
  # >>> f_2 = lambda: 'вызов анонимной функции'
  # >>> f_2
  # <function <lambda> at 0x000001360AF1B240>
  
  # >>> f_1.__name__
  # '<lambda>'
  # >>> f_2.__name__
  # '<lambda>'
  
=================================================================================

00_15 - использование lambda в функциях высшего порядка (фильтрация):
    
    print(*filter(
        lambda n: n > 0,
        map(int, input(' > ').split())
    ), sep='\n')
        
    # >>> print(*filter(lambda n: n > 0, map(int, '2 4 5 -6 -8 6 7 -1 10'.split())), sep='-')
    # 2-4-5-6-7-10
    
======================================================================================

00_30 - графический оконный интерфейс (../apppy/clickCUI.py) // tkinter

    from tkinter import Tk, Button

    root = Tk()
    root.title('start.py')
    root.geometry('400x200')

    btn1 = Button(
        root,
        text='Click',
        command=lambda: root.title('new header')
    )
    btn1.grid(
        row=0, 
        column=0, 
        sticky='nsew', 
        padx=70, 
        pady=70
    )

    root.rowconfigure(0, weight=1)
    root.columnconfigure(0, weight=1)

    root.mainloop()  

========================================================================================
========================================================================================

00_53 - генераторные функции

  ! генераторные выражения - это по сути анонимные генераторные функции (возвращают объект генератор)
  ! генераторные функции возвращают объект генератор всегда
  ! используется ключевое слово yield (пер. вычислить), return используется в исключительных случаях
  
    Объявление
    
    def test_generator() -> 'generator':
        """docstring"""
        
        print('начало выполнения тела генераторной функции')
        
        print('первый шаг')
        yield 1
        
        print('второй шаг')
        yield 2
        
        print('третий шаг')
        yield 3
        
        print('окончание выполнения тела генераторной функции')
        
    ===
    
    >>> def test_generator() -> 'generator':
    ...     print('начало выполнения тела генераторной функции')
    ...     yield 'первый шаг'
    ...     yield 'второй шаг'
    ...     yield 'третий шаг'
    ...     print('окончание выполнения тела генераторной функции')
    ...
    >>> test_generator()
    <generator object test_generator at 0x000001FAF0A74B80>

    >>> test = test_generator()
    >>> test
    <generator object test_generator at 0x000001FAF0A74B80>

    >>> test.__next__()
    начало выполнения тела генераторной функции
    'первый шаг'
    
    >>> test.__next__()
    'второй шаг'
    
    >>> test.__next__()
    'третий шаг'
    
    >>> test.__next__()
    окончание выполнения тела генераторной функции
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    StopIteration


  ! __next__() - вызывается когда мы итерируемся по объекту генератору
  ! __next__() - перехватывает StopIteration
  
  
    ===
    
    for n in gen_obj:
        print(n)
        
    начало выполнения тела генераторной функции
    'первый шаг'
    'второй шаг'
    'третий шаг'
    окончание выполнения тела генераторной функции
    
  ! при повторном переборе:
  ! for n in gen_obj:
  !     print(n)
  ! ничего не произойдет (тело уже вычислено). можно проитерироваться только один раз
  ! нужно использовать не объект, а новый вызов

  * list(test_generator()) -> [1, 2, 3]
  
==========================================================================================

01_16 - Встроенные функции, возвращяющие объекты-генераторы:
    
    +---------------------+-------------------+----------------+    
    | Func                |   type()          |   __next__()   |
    +---------------------+-------------------+----------------+  
    |                     |                   |                |
    | zip()               |   <class 'zip'>   |       +        |
    | slice()             |                   |       +        |
    | reversed()          |                   |       +        |
    | map()               |                   |       +        |
    | enumerate()         |                   |       +        |
    | filter()            |                   |       +        |
    |                     |                   |                |
    +---------------------+-------------------+----------------+ 
    
    
===========================================================================
  ! количество уровней вложенности в выражении  = 994