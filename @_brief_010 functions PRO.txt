===========================================================================

00_01 - анонимные функции lambda (class function)

  ! для ситуаций создания объекта для одноразового использования
  ! вычисляется на месте
  ! допускается передача строго ключевых и строго позиционных аргументов
  
    Объявление с помощью ключевого слова lambda
    
    nums = [1, 2, 3]
    lambda: sum(nums) ** 0.5
    
  ! объявление def - инструкция, в lambda - выражение (возвращает объект)
  ! плохая практика сохрянаять lambda в переменную
  
    func_1 = lambda: 'вызов анонимной функции'
    func_2 = lambda num1, num2: num1 * num2
    
  # >>> f_1 = lambda num1, num2: num1 * num2
  # >>> f_1
  # <function <lambda> at 0x000001360AF1B1A0>
  
  # >>> f_2 = lambda: 'вызов анонимной функции'
  # >>> f_2
  # <function <lambda> at 0x000001360AF1B240>
  
  # >>> f_1.__name__
  # '<lambda>'
  # >>> f_2.__name__
  # '<lambda>'
  
=================================================================================

00_15 - использование lambda в функциях высшего порядка (фильтрация):
    
    print(*filter(
        lambda n: n > 0,
        map(int, input(' > ').split())
    ), sep='\n')
        
    # >>> print(*filter(lambda n: n > 0, map(int, '2 4 5 -6 -8 6 7 -1 10'.split())), sep='-')
    # 2-4-5-6-7-10
    
======================================================================================

00_30 - графический оконный интерфейс (../apppy/clickCUI.py) // tkinter

    from tkinter import Tk, Button

    root = Tk()
    root.title('start.py')
    root.geometry('400x200')

    btn1 = Button(
        root,
        text='Click',
        command=lambda: root.title('new header')
    )
    btn1.grid(
        row=0, 
        column=0, 
        sticky='nsew', 
        padx=70, 
        pady=70
    )

    root.rowconfigure(0, weight=1)
    root.columnconfigure(0, weight=1)

    root.mainloop()

===========================================================================================

02_08 - sorted() + lambda
     
        >>> nums = [-9, 2, 3, 0, 1, 13, 15, 8, -4]
        >>> print(*sorted(nums))
        -9 -4 0 1 2 3 8 13 15
        
        сортировка по модулю
        >>> print(*sorted(nums, key=lambda n: abs(n)))
        0 1 2 3 -4 8 -9 13 15
        
        сортировка по длине слова
        >>> words = ['qwety', 'kjvh', 'python', 'asdfgh', 'windows']
        >>> print(*sorted(words, key=lambda n: len(n)))
        kjvh qwety python asdfgh windows
        
========================================================================================
========================================================================================

00_53 - генераторные функции

  ! генераторные выражения - это по сути анонимные генераторные функции (возвращают объект генератор)
  ! генераторные функции возвращают объект генератор всегда
  ! используется ключевое слово yield (пер. вычислить), return используется в исключительных случаях
  
    Объявление
    
    def test_generator() -> 'generator':
        """docstring"""
        
        print('начало выполнения тела генераторной функции')
        
        print('первый шаг')
        yield 1
        
        print('второй шаг')
        yield 2
        
        print('третий шаг')
        yield 3
        
        print('окончание выполнения тела генераторной функции')
        
    ===
    
    >>> def test_generator() -> 'generator':
    ...     print('начало выполнения тела генераторной функции')
    ...     yield 'первый шаг'
    ...     yield 'второй шаг'
    ...     yield 'третий шаг'
    ...     print('окончание выполнения тела генераторной функции')
    ...
    >>> test_generator()
    <generator object test_generator at 0x000001FAF0A74B80>

    >>> test = test_generator()
    >>> test
    <generator object test_generator at 0x000001FAF0A74B80>

    >>> test.__next__()
    начало выполнения тела генераторной функции
    'первый шаг'
    
    >>> test.__next__()
    'второй шаг'
    
    >>> test.__next__()
    'третий шаг'
    
    >>> test.__next__()
    окончание выполнения тела генераторной функции
    Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
    StopIteration


  ! __next__() - вызывается когда мы итерируемся по объекту генератору
  ! __next__() - перехватывает StopIteration
  
  
    ===
    
    for n in gen_obj:
        print(n)
        
    начало выполнения тела генераторной функции
    'первый шаг'
    'второй шаг'
    'третий шаг'
    окончание выполнения тела генераторной функции
    
  ! при повторном переборе:
  ! for n in gen_obj:
  !     print(n)
  ! ничего не произойдет (тело уже вычислено). можно проитерироваться только один раз
  ! нужно использовать не объект, а новый вызов

  * list(test_generator()) -> [1, 2, 3]
  
==========================================================================================

01_16 - Встроенные функции, возвращяющие объекты-генераторы:
    
    +---------------------+-------------------+----------------+    
    | Func                |   type()          |   __next__()   |
    +---------------------+-------------------+----------------+  
    |                     |                   |                |
    | zip()               |   <class 'zip'>   |       +        |
    | slice()             |                   |       +        |
    | reversed()          |                   |       +        |
    | map()               |                   |       +        |
    | enumerate()         |                   |       +        |
    | filter()            |                   |       +        |
    |                     |                   |                |
    +---------------------+-------------------+----------------+ 

=============================================================================================

01_37 - объект генератор отличается от прочих итерируемых объектов - не хранит объект в памяти,
        объект генератор - вычисляет объект (инструмент для решения задач связанных либо с объемными
        объектами в памяти, когда хранить объекты не выгодно, например двоичные данные, либо с
        условно-бесконечным счетчиком..., либо специфические последовательности)
        
    Пример - бесконечный цикл.(!!!)
    
    def infinite_counter(start: int, step: int = 1) -> 'generator':
        """docstring"""
        
        while True:
            yield start
            start += step
            
    ===
    
    for n in infinite_counter(10, 5):
        print(n, end=' ')
        
        
==========================================================================================

01_56 - расходящаяся последовательность

    def divergent_sequence(start: int, end: int) -> 'generator':
        while n < start:
            yield n
            yield -n
            n += 1
            
    -> 1 -1 2 -2 3 -3 4 -4 5 -5 6 -6 7 -7 8 -8 9 -9
    




    
    
===========================================================================
  ! количество уровней вложенности в выражении  = 994