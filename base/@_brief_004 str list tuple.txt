========================================================================================================

Индексация последовательностей

========================================================================================================

00_11 - Объект: тип str - является индексируемой последовательностью
    
00_27 - Строки - итерируемые объекты с элементами (символами) 

    text = 'Python is cool!'
    len(text) = 15 
    
  ! len - функция, которая возвращает количество элементов
 
    элементом строки является символ, который в свою очередь так же является объектом типа str
    type(text) = class 'str'
    type(text[0]) = class 'str'
  
    строка состоящая из 1-го символа, является итерируемой
    char = 'ж'
    len(char) = 1
    
  ! Элементами объекта str не могут быть последовательности другого типа (только str). *Строка - это гомогенный массив 
    hex_number = 'ff' (255)
    hex_number = 'f0' (160) // 0 - символ str, не int
    
    numbers_str = '[1, 2, 3]'
    numbers = [int(n) for n in numbers_str.strip('[]').split(', ')]

  ! Парсинг - посимвольное (поэлементное) прохождение по тексту, для реализации каких либо действий.

========================================================================================================
    
00_55  Последовательности - изменяемы и не изменяемые (карточка последовательности)
  
    Неизменяемые - те которые невозможно изменить без создания нового объекта в памяти.

    Изменяемые - при изменении объекта, новый объект в памяти не создаётся, а модифицируется текущий.

    str, tuple - неизменяемые (методы объектов создают новые объекты)
    list - изменяемый (методы объекта модифицируют существующий объект) 

========================================================================================================

00_59 Индексация (карточка)

  ! Индекс - целые числа, начиная с 0, которое сопоставляется каждому элементу любой последовательности.

    text = 'Python is cool!'
  > print(text[0], text[1], text[2]) - обращение по индексу text[i]
    P y t
    
  ! Все индексируемые последовательности имеют упорядоченные индексы.
  ! Индексация и итерирование - разные понятия
  
  > print(f'i = 0 : {text[0]},\ni = 1 : text[1],\ni = 2 : text[2]')
    i = 0 : P
    i = 1 : y
    i = 2 : t
  
  > print(text[14])  --- !
  > print(text[15])  --- IndexError
  > print(text[-1])  --- !
  > print(text[-2])  --- l
  > print(text[-15]) --- P
  > print(text[-16]) --- IndexError
  
  ! Отрицательная индексация используется для обращения к последним элементам без явного вычисления длинны
    (len), но следует помнить, что не явным образом длина все равно будет вычислена интерпретатором.
    Последний отрицательный индекс по модулю равен длине.
  
  > print('НД'[True])  --- Д - не явное приведение True к объекту типа int - 1
  > print('НД'[False]) --- Н - не явное приведение False к объекту типа int - 0
  
 ========================================================================================================

 01_52 Списки - list
  
    Списки - последовательно в которых мы можем упорядоченным образом сохранять любые объекты,
    в том числе изменять элементы в самом списке, при этом не изменяя (не создавая) объект списка.
    Список - является индексируемой (гетерогенной) последовательностью
    
    list_1 = [1, 1.5, 'abc', [1, 2.05, True]] - элементами списка могут быль объекты любых типов
    
    numbers = [1, 2, 3]
    type(numbers) --- class 'list'
    
    numbers[2]  --- 3
    numbers[-2] --- 2
    
    list_1[3][2] --- True - обращение ко вложенным спискам
    
    list_1[0] = 'изменение' --- list_1 = ['изменение', 1.5, 'abc', [1, 2.05, True]] 
    
  ! id() - возвращает (число) идентификатор объекта (ссылка, адрес) в области памяти.
  ! при изменении list - id остаётся неизменным
  ! применяя модифицирующие методы к объектам str, tuple - создаётся новый объект с уникальным id
  
    >>> num = [0]
    >>> num += [1]
    >>> print(num)
    [0, 1]
    >>> print(id(num))
    2565503750912
    >>> num += [4] --- не создаст новый объект
    >>> print(id(num))
    2565503750912
    >>> num = num + [9] --- создаст новый объект
    >>> print(id(num))
    2565503750016
    >>>

========================================================================================================

02_19 Ссылочная зависимость

    n_1 = [1, 2, 3]
    n_2 = n_1 (в переменную n_2 присваивается не значение переменной n_1, a ссылка на тотже самый объект)
    n_1[0] = 'new' - при изменении объекта используя ссылку (переменную) n_1
    print(n_2) --- ['new', 2, 3] - получим, что элементы объекта видны и через n_2.
    
  ! Изменение списка в локальном пространстве имён, ведёт к его изменению и в глобальном пространстве имён
  ! Изменяемые объекты передаются по ссылке
  ! Ссылочная зависимость касается всех изменяемых объектов
  
==========================================================================================================
  
    Кеширование малых чисел (работает с числами до определённого значения)
    a = 12
    b = 12
    id(a) == id(b)
    Кеширование - часто используемые объекты кэшируются (автоматически создаются в памяти).***
    
    Test:
    Python 3.11.3 (tags/v3.11.3:f3909b8, Apr  4 2023, 23:49:59) [MSC v.1934 64 bit (AMD64)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
>>> a = 10
>>> b = 10
>>> print(id(a), id(b))
    140726187582536 140726187582536 - совпадают
>>> a = 10**6
>>> b = 10**6
>>> print(id(a), id(b))
    2284453160176 2284453163344
>>> a = 10**5
>>> b = 10**5
>>> print(id(a), id(b))
    2284453162544 2284453160176
>>> a = 10**4
>>> b = 10**4
>>> print(id(a), id(b))
    2284450003824 2284453162544
>>> a = 10**3
>>> b = 10**3
>>> print(id(a), id(b))
    2284453163312 2284450003824
>>> a = 10**2
>>> b = 10**2
>>> print(id(a), id(b))
    140726187585416 140726187585416 - совпадают
>>> a = 1000000000
>>> b = 1000000000
>>> print(id(a), id(b))
    2284453160176 2284453163280
>>> a = 1000
>>> b = 1000
>>> print(id(a), id(b))
    2284453163344 2284453162928
    
=======================================================================================================

02_34 Срезы - Операции с индексами позволяющие взять часть последовательности

    примеры в файле урока
    
    obj[начальный индекс, конечный индекс, шаг] - всегда возвращается новый объект
    
    замена части списка
    l = [1,2,3]
    l[:2] = [100,200]
    print(l) --- [100,200,3]
  
=======================================================================================================
  
Другое полезное
  
02_05    Оператор расширенного присваивания:
        
    a = 4
    a += 1
    print(a) --- 5
    
    a -= 3
    print(a) --- 2
    
    Со строками подобным образом работает конкатенация
    
    a = 'abc'
    a += 'd'
    print(a) --- 'abcd' - новый объект в другой области памяти
    
  ! Со списками расширенное присваивание работает также, как и конкатенация строк
  
    nums = [1, 2, 3]
    nums += [4, 5, 6]
    print(nums) --- [1, 2, 3, 4, 5, 6] - при этом id nums не изменится т.к. nums не новый объект
    
02_31 Создание копии

    a = [0]
    c = a.copy() - при помощи метода copy() - выделяется в памяти новая область куда дублируется новый объект
