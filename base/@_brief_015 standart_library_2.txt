===================================================================================

2023.09.08 - СТАНДАРТНАЯ БИБЛИОТЕКА PYTHON - ОБЗОР 2

===================================================================================

00_04 - Регулярные выражения (модуль re)

    https://regex101.com
    
    
    stdlib5.py
    ----------
    from re import compile
    
    pattern_binary = compile(r'(?:b|0b)?[01]+')
    
    def is_binary(bin_number: str) -> bool:
        """Функция проверяет, является ли строка бинарнарным числом."""
        return bool(pattern_binary.fullmatch(bin_number))
        
    is_binary('0101') -> True
    is_binary('b11') -> True
    is_binary('0b11001') -> True
    is_binary('1b11001') -> False
    is_binary('10b11001') -> False
    
    
    stdlib6.py
    ----------
    from datetime import date
    from re import compile

    pattern_date = compile(
        r'(?P<day>0[1-9]|[12]\d|3[01])'
        r'\.'
        r'(?P<month>0[1-9]|1[012])'
        r'\.'
        r'(?P<year>\d{3,4})'
    )

    text = '''источник Описывает период с 21.07.1943 по 21.07.1943 г. 
    Сведения. № документа: 2444, Дата создания документа: 21.07.1943 г 
    Архив: ЦАМО, Фонд: 203, Опись: 2843, Дело: 430, Лист начала документа в деле: 13 
    Авторы документа: ВорФ, подполковник Берлин, майор Вишняков Описывает боевую операцию: 
    Оборонительный период битвы под Курском. 5.7-23.7.43 г.'''

    results = pattern_date.findall(text)
    # >>> results
    # [('21', '07', '1943'), ('21', '07', '1943'), ('21', '07', '1943')]

    dates = [
        date(*map(int, d[::-1]))
        for d in results
    ]
    # >>> dates
    # [datetime.date(1943, 7, 21), datetime.date(1943, 7, 21), datetime.date(1943, 7, 21)]
    
    
===================================================================================

00_39 - модуль itertools - для работы с итерируемыми объектами

    
    stdlib7.py
    ----------
    from itertools import chain
    
    numbers = range(10, 100, 10)
    words = set('abcdef')
    
    print(*chain(numbers, words), sep='-') -> 10-20-30-40-50-60-70-80-90-b-a-c-e-f-d
    
    
    ----------
    filterfalse()
    islice()
    zip_longest()
    pairwise()
    dropwhile()
    takewhile()
    compress()
  ! комбинаторика

===================================================================================

01_09 - модуль operator - функции - эквиваленты операторов
  
===================================================================================

01_30 - functools - большинство функций являющихся декораторами.

    @cache
    def factorial(n):
        return n * factorial(n-1) if n else 1
        
    @lru_cache
    def count_volwes(sentence):
        return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')
        
    partial() -> partial(int, base=2) - создает аналог функции с заменой пареметра по умолчанию
    reduce() -> (((((1+2)+3)+4)+5)+6)

    @singledispatch -> позволяет использовать одну и туже функцию по разному, в зависимости от типов переданных аргументов
    
    @wraps -> решает проблему с __doc__ ... (сигнатурой) декорируемой функции ()

===================================================================================

01_57 - configparser - работа с файлами

    configparser.ConfigParser()
    
  ! используется для первого промежуточного проекта
  
===================================================================================
  
02_05 - tomllib - формат configfile для людей

  ! Только для Python 3.11
    
    tomllib.load()
    tomllib.loads()
    
    stdlib8.py
    ----------
    
====================================================================================
    