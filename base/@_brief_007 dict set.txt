==========================================================================================

00_01 - основы словарей и множеств (dict + set)

    такие типы назвают отображением, т.к. они хранят пары объектов (ключ, значение)
    
    литерал словаря выглядит так: alphabet = {'a': 1, 'b': 2, 'c': 3}
    
    print(type(alphabet)) - класс - class 'dict'
    print(alphabet) - строковое представление - {'a': 1, 'b': 2, 'c': 3} - такое же как и литерал
    print(len(alphabet)) - размер - 3 (количество элементов)
    
00_10 - словарные методы

    получение ключений:
    
    alphabet.keys() - dict_keys(['a', 'b', 'c']) - class 'dict_keys'
    
    получение значений:
    
    alphabet.values() - dict_values([1, 2, 3]) - class 'dict_values'
    
    получение элеентов:
    
    alphabet.items() - dict_items([('a', 1), ('b', 2), ('c', 3)]) - class 'dict_items'
    
00_15 - особенности ключей и значений

    Значением - может быть абсолютно любой объект
    
    Ключем - может быть не любой объект (2 ограничения)
        1 - все ключи должны быть уникальны
        2 - могут быть только хешируемые (*неизеняемые) объекты
        
        * изменеяемые - не хешируемые
        
00_27 - словарь с месяцами

    days = {1:31, 2:28, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31}
    
    обращение к значению по ключу:
    print(days[2]) - 28
    
    month_day = {
        'янв':31,
        'фев':28,
        'мар':31,
        'апр':30,
        'май':31,
        'июн':30,
        'июл':31,
        'авг':31,
        'сен':30,
        'окт':31,
        'ноя':30,
        'дек':31
    }
        
    print(month_day['дек']) - 31
    
  ! обращение по несуществующему ключу выбросит исключение - KeyError
  
00_39 - Словари могут содержать ключи разных типов

  ! Для int и float ключей принимаются одинаковые хеши (1 и 1.0 ключей быть не может)
  
00_50 - Изменение словарей

    numbers[2] = newObj - добавление по новому еще не существующему ключу (либо замена по существующему)
    
    numbers.pop[key] - рекомендованыый метод удаления элемента из словаря по ключу 
        pop - возвращает ЗНАЧЕНИЕ удаленного элемента
        
  ! del - не рекомендуется использовать на текущем этапе.

    numbers |= {'a': 1, 'b': 2} - обновление словаря numbers другим словарем (существующие ключи заменятся)
    
    dict1 | dict - ' | ' - оператор слияния (направленный) - создается новый объект.

    |= - обновление (либо метод update())
    
    | - слияние
    
01_14 - Когда-то словари были неупорядоченными (до версии 3.6)

================================================================================================

01_36 - итерирование по словарю

    при итерировании в переменную цикла записываются ключи словаря
    
    prod = {
        'фрукты' = ['яблоко', 'персик', 'слива'],
        'крупы' = ['гречка', 'рис', 'манка'],
        'молочные' = ['молоко', 'сметана', 'сливки']
    }

    for key in prod:
        print(key) - фрукты крупы молочные
        print(prod[key]) - ['яблоко', 'персик', 'слива'] ['гречка', 'рис', 'манка'] ['молоко', 'сметана', 'сливки']
    
    
    итерирование по значениям
    при итерировании по значениям мы не всегда можем изменить значения (зависит от типа объекта)
    
    for values in prod.values():
        print(values) - ['яблоко', 'персик', 'слива'] ['гречка', 'рис', 'манка'] ['молоко', 'сметана', 'сливки']
        
        
    итерирование по элементам
    
    for key, value in prod.items():
        всегда (на каждой итерации) возвращяются кортежи из 2 элементов (key, value)
        
        
    при приобразовании словаря в список - list(dict()) - мы получим список ключей
    при проверке наличия объекта - 'персик' in dict() - проверка осуществится только по ключам
    
========================================================================================================

01_58 - множества - set() - class 'set' (frozenset - неизменяемое множество)

  ! множество - коллекция уникальных объектов 
  ! элементами множества могуть быть - только неизменяемые объекты (не списки, не словари, не множества)
  
    sell = {10, 15, 20, 20} 
    print(sell) - {10, 15, 20} - элемент 20 встречается только 1 раз
    print(len(sell)) - 3
    
  ! множество не является последовательностью и не упорядоченный объект (порядок не гарантирован)
  
  ! множество не является индексирумым
  
02_17 - итерирование по множеству

    for elem in {1, 2, 3, 4, 5}:
        print(elem) - 1 2 3 4 5
        
    
02_19 - методы множеств

    множества могут являться подмножествами другого множества.
    
    mammals = {'tiger', 'camel', 'sheep', 'whale', 'walrus'}
    
    aquatic_mammals = {'whale', 'walrus'}
    
    проверка на подмножество - aquatic-mammals < mammals - оператор < или <= 
        
    проверка на надмножество - mammals > aquatic-mammals - оператор > или >=    
        
        
  ! метод isdisjoint() - проверка разьединения множеств
  
    mammals = {'tiger', 'camel', 'sheep', 'whale', 'walrus'}
    
    reptiles = {'turtle', 'snake'}
    
    mammals.isdisjoint(reptiles) - True
    
02_26 - операции со множествами

  ! Объединение множеств - объединение всех элементов разных множеств

    reptiles | aquatic-mammals - {'turtle', 'snake', 'whale', 'walrus'}
    
  ! Пересечение множеств - в итоговое войдут только те, которые есть и в первом и во втором
  
    set_1() & set_2()
    
  ! Разность множеств (вычитание) - важен порядок
  
    set_1() - set_2()
    
  ! симметричная разность
  
    set_1() ^ set_2()
    
    
  ! операторы |  &  ^  -  // создают новое множество
  ! операторы |= &= ^= -= // обновляют множество
  
02_40 - обзор методов множеств в документации   
        
===============================================================================================

Другое полезное 

    списки, словари, множества - изменяемые объекты
    
    d{}, d = dict() - создание пустого словаря
    
    s = set()       - создание пустого множества
    
    