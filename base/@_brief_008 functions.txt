00_01

Парадигмы разработки

1. Процедурная парадигма - 
    низкоуровневые языки, 
    файл выполняется последовательно, 
    самая простая концепция,
    нет возможно использовать повторяющийся код
    
2. Функциональная парадигма - 
    ввод понятия блока кода (функции),
    создание функций, 
    возможность повторно использовать повторяющийся код
    
3. Объектно-ориентированная парадигма
    
Функции:
    1 этап - объявление функции
    2 этап - вызов функции (в. т.ч. многократно)
    
===================================================================================

Функции - тоже объекты

===================================================================================

00_24 ключевое слово def (definition) - определение, обявление

    # объявление функции -> является инструкцией (объект не создается)!!!
    def test_func(): -> заголовок функции, далее тело
        print('вызвана test_func')
        print(10**2)
        
    # вызов функции -> является выражением, вычисляемое, возвращает объект
    test_func()
    test_func()
    
  ! Если в функции явно не прописан тип возвращаемого объекта, то функция вернет None
  ! В памяти существует тольео один объект None
  
    a = test_func()
    print(a) 
    -> None
    
====================================================================================

00_48 ключевое слово return (инструкция возвращает значени вычесленного выражения)
    
    def punctuation():
        return '.,;:!?-\'\"()'
        
    punctuation() - вызвалась, вычислилась, объект создан в памяти и забыт (значение не использовано)
    puncs = punctuation() - сохранено в переменную, которую в последующем можно использовать
    
====================================================================================

00_56 Аннотации - инструмент подписи типов объектов которые принимает и возвращает функция
    
  ! Аннотация - просто подписи для разработчиков (интерпритатором не исполняется)
  
    # -> str - аннотация: функция возвращает объект str
    
    def punctuation() -> str:
        return '.,;:!?-\'\"()'

    Ссылки на документацию по аннотациям
        PEP 483
        PEP 484
        PEP 585

=========================================================================================
            
01_18 Документация функций

    def punctuation() -> str:
    """ Что делает функция? -> Функция возвращает строку с распространенными знаками препинания."""
        return '.,;:!?-\'\"()'
        
        
==============================================================================================

01_21 - Специальные атрибуты

    punctuation.__name__ -> 'punctuation'
    
    punctuation.__doc__ -> 'Что делает функция? -> Функция возвращает строку с распространенными знаками препинания.'
    
    punctuation.__annotations__ -> {'return': <class 'str'>}
    
    punctuation.__defaults__ -> возвращает кортеж с параметрами для которых заданы значения по умолчанию
    
==============================================================================================

!!! наименование, документация, аннотации, список параметров - составляют СИГНАТУРУ функции !!!

==============================================================================================

01_42 - Параметры функции

    параметры - переменные в заголовке при объявлении функции
    аргументы - объекты передаваемые в значения параметров при вызове функции
    
  ! порядок передачи ВАЖЕН
    
    def adder(num1: int, num2: int) -> int:
        return num1 + num2
        
    adder(1, 9) -> 10
    adder(20, -20) -> 0
    
==================================================================================================

01_52 Параметры
    
    1. Позиционные
    2. Позиционно-ключевые
    3. Ключевые
    4. Обязательные
    5. Необязательные
    
  ! Функция с одним необязательным параметром:
  
    def split_text(text: str, separator: str = ' ') -> list[str]: #list[str, int]
        return text.split(separator)
    
==================================================================================================    
    
02_10

    def calculator(num1: int, num2: int, operation: str) -> int | float:
        """Возвращает результат математической операции для двух чисел
        символ операции передается в operation"""
        ...
        return num1 + num2
            
    calculator(1, 2, '+') -> 3 - только позиционная передача
    calculator(1, 2, operation='-') -> -1 - позиционно-ключевая передача
    calculator(num2=1, num1=2, operation='-') -> 1 - только ключевая передача (порядок НЕ ВАЖЕН!)

  ! Сначала переадаются аргументы по позиции потом по ключу, иначе будет ошибка. 


===================================================================================================
---------------------------------------------------------------------------------------------------

18.08.2023 - ПЕРЕДАЧА АРГУМЕНТОВ В ФУНКЦИЮ (СПОСОБЫ)

---------------------------------------------------------------------------------------------------
===================================================================================================

00_01 - ключевое слово return - прерывает выполнение функции и возвращает результат выполнения

=====================================================================================================
    
00_27 - передача аргументов строго по строго по ключу
    
    def process_track_info(
            *, <-   указание интерпритаору на то, что все аргументы должны быть переданы строго по ключу
            song_title: str,
            artist: str,
            album: str,
            channels: int,
            bit_depth: int,
            sample_rate: float
          ! лучше использовать двойной отступ
    ):
        pass
        
    В функции выше (process_track_info), лучше всего использовать передачу строго по ключу.
    
    НЕУДОБНОЕ ИСПОЛЬЗОВАНИЕ       |   УДОБНОЕ ИСПОЛЬЗОВАНИЕ
                                  |
    process_track_info(           |   process_track_info(
        'Boom',                   |       song_title='Boom',
        'Boomers',                |       artist='Boomers',
        'BOOM!',                  |       album='Boomers',
        6,                        |       channels=6,
        16,                       |       bit_depth=16,
        48.0                      |       sample_rate=48.0
    )                             |   )
  
  ! разделитель * - указывается при объявлении функции (при вызове передача строго по ключу)
    после * - все параметры строго ключевые
  
================================================================================================================

00_50 - передача аргументов строго по позиции

    def calculator(
            num1: int,
            num2: int,
            /,
            *,
            operation: str
    ) -> int | float:
        ...
        
  ! до разделителя / - параметры строго позиционные
  ! после разделителя * - параметры строго ключевые
  
    корректный вызов теперь только - calculator(1, 2, operation='-') - ЕДИНООБРАЗИЕ при вызове

    
    def process_point(x: int, y: int, /):
        ...
        
    process_point(1, 1) - строго позиционный 'x' и 'y'
    
===========================================================================================================

00_59 все виды параметров в одной функции

    def func_name(pos1, pos2, /, pos_key, *, key1, key2) - общая сигнатура без произвольных наборов
        """docstring""" после docstring можно не писать заглушку и ошибки не будет
        
  ! параметры со значениями по умолчанию должны находиться после всех позиционных параметров
  
=============================================================================================================

01_12 распаковка аргументов в параметры функции

    numbers_pairs = [(1, 9), (3, 7), (11, 0)]
    
    for pair in numbers_pairs:
        calculator(*pair, '+') -> *pair распаковка кортежа по позиции
        
    -> 10, 10, 11
    
    ----
    
    operation_history = [
        {'num1': 1, 'num2': 9, 'operation': '+'},
        {'num1': 3, 'num2': 7, 'operation': '+'},
        {'num1': 11, 'num2': 0, 'operation': '+'}
    ]
    
    for oper in operation_history:
        calculator(**oper) -> *oper (словарь) распаковка словаря
        
    -> 10, 10, 11
    
  ! * распаковка списка, кортежа
  ! ** распаковка словаря
  
  
==============================================================================================================

01_39 функции с произвольным количеством аргументов 

    произведение переданных чисел
    
    def product(*numbers: int | float) -> int |float:
        # print(f'{type(numbers)}\n{numbers}')
        if 0 in numbers:
            return 0
        result = 1
        for num in numbers:
            result *= num
        return result
        
    вызываем:
    
    тесты print(f'{type(numbers)}\n{numbers}')
    product(1, 2) -> <class 'tuple'> - (1, 2)
    product() -> <class 'tuple'> - ()
    product(*range(10, 60, 10)) -> <class 'tuple'> - (10, 20, 30, 40, 50)
    
  ! все аргументы передаются по позиции (ключей нет)
  ! numbers - произвольный кортеж позиционных аргументов (всегда кортеж) - аннотируются элементы кортежа
  
  
===========================================================================================================
  
01_52 функция print (собственный вариант) c произвольным количеством аргументов
    
    def print_return(*args, sep: str = ' ', end: str = '\n') -> str:
        return sep.join(str(arg) for arg in args) + end
        
    
===========================================================================================================

02_03 функция с аргументами перед произвольным кортежем. (table_print)