===============================================================================================

Функции высшего порядка, декораторы

===============================================================================================

00_01 - функция является объектом

    def test(arg1, arg2: str = '') -> None:
        """docstring"""

    test.__name__ -> 'test'
    test.__annotations__
    test.--defaults__
    test.__kwdefaults__ 
    test.__doc__
    test.__code__
     
    dir(test) -> вернет список всех атрибутов
    dir(test.__code__) -> 


===============================================================================================    

00_14 - функции высшего порядка -> которя принимает в качестве аргумента другой объект-функцию

    пример функций:
        map, filter,
        
    
  ! Дженерики - объекты специального типа ичпользуемые только для аннотаций
    Iterable = str | range | tuple | list | frozenset | dict
    
    аналог map: упрощенный
    
    def map(function: 'function', iterator: Iterable) -> list:
        """
            Функция высшего порядка - перебирает элементы в itetator
            и кажный элемент перадает в качестве аргумента в function
            результаты работы function(elem) добавляет в список result,
            который возвращает в итоге
        """
        result = []
        for elem in iterator:
            result.append(function(elem))
        return result
        
    >>> numbers = [0.79, 1.1, -2.9]
    >>> map(round, numbers) 
    [1, 1, -3]
    
    >>> map(int, '1234567') 
    [1, 2, 3, 4, 5, 6, 7]
    
    >>> [int(ch) for ch in '123']
    [1, 2, 3]
    
===================================================================================================
    
00_36 аналог map 2

    def map(
            function: 'function', 
            iterator: Iterable,
            *iterators: Iterable
    ) -> list:
        # iterators = (iterator, ) + iterators
        iterators = iterator,  *iterators
        
        result = []
        for args in zip(*iterators):
            result.append(function(*args))
        return result
    
    
  ! >>> map(pow, [10, 3, 2], [3, 10, 2])
    [1000, 59049, 4]
    
    ===
    
    >>> print(*zip([1, 2, 3], ('a', 'b', 'c')), sep=' --- ')
    (1, 'a') --- (2, 'b') --- (3, 'c')
    
    >>> print(*zip([1, 2, 3]), sep=' --- ')
    (1,) --- (2,) --- (3,)
    
    >>> print(*zip([1, 2, 3], ('a', 'b', 'c'), 'АБВ'), sep=' --- ')
    (1, 'a', 'А') --- (2, 'b', 'Б') --- (3, 'c', 'В')
    
====================================================================================================
    
00_56 аналог filter

    Iterable = str | range | tuple | list | frozenset | dict

    def filter(function: 'function', iterator: Iterable) -> list:
        
        result = []
        for elem in iterator:
            if function(elem): - функция предикат
                result.append(elem)
        return result
        
  ! предикат - термин применяемый к функциям возвращающим логическое значение
  ! пример на использованние filter - приведен в function14.py (список слов)
  
  
====================================================================================================

01_08 - функция обработчик слов (function15.py)

    def process_text(word_processor: 'function', text: str):
        """docstring"""
        
        return ' '.join(
            word_processor(word)
            for word in text.split()
        )
    punctuation = '.,;:!?'
    
    def strip_punctuation(word: str) -> str:
        return word.strip(punctuation)
        
    text = 'dsbgpgidsbsgppdf.,;:!?124325odgds.,;:!?lehbbgod'
    
    >>> process_text(strip_punctuation, text)
    'dsbgpgidsbsgppdf124325odgdslehbbgod'
    
    
====================================================================================================

01_14 - шифр Цезаря (без сохранения регистра)

    def caesar_encode(word: str, shift: int = 3) -> str:
        return ''.join(
            chr((ord(ch.lower()) - 97 + shift) % 26 + 97) if ch.isalpha() else ch
            for ch in word
        )
        
=====================================================================================================

01_35 - декораторы

    Декоратор - функция высшего порядка (decorator1.py)
  ! принимает на вход вызываемый объект-функции и возвращает вызываемый объект-функции
  ! позволяет добавить функциональность
  ! применяется к различным функциям
    
    def decorator(function: 'function'):
        """функция-декоратор"""
    
        print('вызов decorator()')
        print('    перед созданием функции-обёртки')
        
        def wrapper(*args, **kwargs):
            """функция-обёртка"""
            
            print('        вызов wrapper()')
            
            print('            перед вызовом декорируемой функции')
            
            result = function(*args, **kwargs)
            
            print('            после вызова декорируемой функции')
            
            return result
            
        print('    после создания функции-обёртки')
        
        return wrapper
            
  ! function - декорируемая функция
  
  
    def test_func():
        """тестовая функция"""
        print('                вызов тествой функции')
        
  ! test = decorator(test)
  
    ===
    
    >>> test()
                вызов тествой функции
    
    >>> test = decorator(test)
    вызов decorator()
        перед созданием функции-обёртки
        после создания функции-обёртки

    >>> test()
            вызов wrapper()
                перед вызовом декорируемой функции
                    вызов тествой функции
                после вызова декорируемой функции
                
================================================================================================

01_57 ...