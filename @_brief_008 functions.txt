00_01

Парадигмы разработки

1. Процедурная парадигма - 
    низкоуровневые языки, 
    файл выполняется последовательно, 
    самая простая концепция,
    нет возможно использовать повторяющийся код
    
2. Функциональная парадигма - 
    ввод понятия блока кода (функции),
    создание функций, 
    возможность повторно использовать повторяющийся код
    
3. Объектно-ориентированная парадигма
    
Функции:
    1 этап - объявление функции
    2 этап - вызов функции (в. т.ч. многократно)
    
===================================================================================

Функции - тоже объекты

===================================================================================

00_24 ключевое слово def (definition) - определение, обявление

    # объявление функции -> является инструкцией (объект не создается)!!!
    def test_func(): -> заголовок функции, далее тело
        print('вызвана test_func')
        print(10**2)
        
    # вызов функции -> является выражением, вычисляемое, возвращает объект
    test_func()
    test_func()
    
  ! Если в функции явно не прописан тип возвращаемого объекта, то функция вернет None
  ! В памяти существует тольео один объект None
  
    a = test_func()
    print(a) 
    -> None
    
====================================================================================

00_48 ключевое слово return (инструкция возвращает значени вычесленного выражения)
    
    def punctuation():
        return '.,;:!?-\'\"()'
        
    punctuation() - вызвалась, вычислилась, объект создан в памяти и забыт (значение не использовано)
    puncs = punctuation() - сохранено в переменную, которую в последующем можно использовать
    
====================================================================================

00_56 Аннотации - инструмент подписи типов объектов которые принимает и возвращает функция
    
  ! Аннотация - просто подписи для разработчиков (интерпритатором не исполняется)
  
    # -> str - аннотация: функция возвращает объект str
    
    def punctuation() -> str:
        return '.,;:!?-\'\"()'

    Ссылки на документацию по аннотациям
        PEP 483
        PEP 484
        PEP 585

=========================================================================================
            
01_18 Документация функций

    def punctuation() -> str:
    """ Что делает функция? -> Функция возвращает строку с распространенными знаками препинания."""
        return '.,;:!?-\'\"()'
        
        
==============================================================================================

01_21 - Специальные атрибуты

    punctuation.__name__ -> 'punctuation'
    
    punctuation.__doc__ -> 'Что делает функция? -> Функция возвращает строку с распространенными знаками препинания.'
    
    punctuation.__annotations__ -> {'return': <class 'str'>}
    
    punctuation.__defaults__ -> возвращает кортеж с параметрами для которых заданы значения по умолчанию
    
==============================================================================================

!!! наименование, документация, аннотации, список параметров - составляют СИГНАТУРУ функции !!!

==============================================================================================

01_42 - Параметры функции

    параметры - переменные в заголовке при объявлении функции
    аргументы - объекты передаваемые в значения параметров при вызове функции
    
  ! порядок передачи ВАЖЕН
    
    def adder(num1: int, num2: int) -> int:
        return num1 + num2
        
    adder(1, 9) -> 10
    adder(20, -20) -> 0
    
==================================================================================================

01_52 Параметры
    
    1. Позиционные
    2. Позиционно-ключевые
    3. Ключевые
    4. Обязательные
    5. Необязательные
    
  ! Функция с одним необязательным параметром:
  
    def split_text(text: str, separator: str = ' ') -> list[str]: #list[str, int]
        return text.split(separator)
    
==================================================================================================    
    
02_10

    def calculator(num1: int, num2: int, operation: str) -> int | float:
        """Возвращает результат математической операции для двух чисел
        символ операции передается в operation"""
        ...
        return num1 + num2
            
    calculator(1, 2, '+') -> 3 - только позиционная передача
    calculator(1, 2, operation='-') -> -1 - позиционно-ключевая передача
    calculator(num2=1, num1=2, operation='-') -> 1 - только ключевая передача (порядок НЕ ВАЖЕН!)

  ! Сначала переадаются аргументы по позиции потом по ключу, иначе будет ошибка. 

