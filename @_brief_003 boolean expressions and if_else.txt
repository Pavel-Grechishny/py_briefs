================================================================================================

00_00 Работа с GitHub (token)
    Для команд pull и push всегда добавлять origin main

================================================================================================

00_29 Операторы сравнения

    Всего операторов сравнения - 6 (==, !=, >, <, >=, <=)
    Все операторы сравнения возвращают объект типа bool (True, False)
    
    '==' - проверка на равенство
    '!=' - проверка на неравенство
    '>'  - проверка строго больше
    '<'  - проверка строго меньше
    '>=' - проверка больше либо равно
    '<=' - проверка меньше либо равно
    
    1 == 1   - True (когда левый и правый операнды равны как значения
    1 == 1.0 - True (int(1) == float(1.0)) - равенство значений
    
    Операнд - выражение слева и справа от БИНАРНОГО (двухместного) оператора.

    1 + 5 == 2.5 + 3.5 - True (! приоритет: вычисляется 6 == 6.0)
    
    Все математические операторы по приритету выше, чем операторы сравнения
    У всех операторов сравнения приоритет одинаковый
    
    1 != 1 - False (возвращает True если операнды не равны)
    
    2 > 2 - False
    2 > 1 - True
    2 >= 2 - True
    2 < 3 - True
    2 >= 3 - False
    
    При помощи операторов сравнения получам условные выражения
    Используются в условных конструкциях, там где оператор ожидает получить 
    объект логического типа (boll) - if_elif, while, либо в функции
    
    * Выражение может быть вычислено
    
    prompt = 'введите число: '
    n, m = int(input(prompt)), int(input(prompt))
    
    n_m = n > m
    
    print(n_m) (после вычисления n_m будет ссылаться на True либо False)
    int(n_m) - 1 либо 0
    
================================================================================================

00_52 Условные конструкции (if)

    Условных конструкций несколько:
    
00_53 - 1. Инструкция if_elif_else
    
    if (ожидает bool, если будет объект другого типа, то он будет проверен на истинность) 
        
    a = 5
    if a: Объект int(a) будет проверен на истинность (bool(a), bool(5) == 1)
    
    if bool(a): - явная проверка на истинность
    if a:       - интерпритатор неявным образом осуществляет проверку на истинность
        
    text = '' - получаем текст из файла, либо input, либо ....
    if text: - (text == '' получим False) (text = ' ' получим True, если есть хотябы 1 символ)
        
    if 1 == 1 (логическое (сравнительное) выражение)
    if 'python'.isalpha() - метод также возвращает логическое True либо False
        
    Заголовок блоковой конструкции - это первая строчка конструкции (if text_1 == text_2:)
    Блок возникат под соответсвужим заголовком

01_04 - Блоки, отступы

    if 1 == 1: - 0-й уровень начало блоковой конструкции
        print('1') 1-й уровень (отступ несколько пробелов или табуляции)
         print('ошибка отступа') - !!! соблюдай уровни отступов - стандарт 4 пробела для .py
    Блок закончился
    Двоеточие ':' в конце строки (заголовка) означает что дальше идет тело блочной конструкции
    После заголовка обязательно должен быть написан блок
  ! pass заглушка блока (и не собираемся писать) или '...' заглушка (акцент к возврату и добавлению кода)
    Пробел предпочтительнее, перед табуляцией. Смешивать пробелы и табуляцию нельзя и плохо.
    Командная строка не умеет подменять символы пробела.
        
    
01_34 - Минимальный вариант условной конструкции

    if 1 == 1:
        print('1 = 1')
        
01_37 - Варианты использования условных конструкций

    if False:
        ...
    else:
        print('else выполняется если все предыдущие блоки не были выполнены')
        
  ! Из условной конструкции будет выполнен только один блок, несколько блоков не выполняются.
  
    if False: 
        ...
    elif True:
        print('проверяется еще одно условие и выполняется')
        
  ! Выполняется блок условие в котором возвращает True, остальные блоки не проверяются и не выполняются.
  
  ! Принцип работы - последовательная проверка условий, пока не вернется True. 
    Далее выполнение True блока и ингнорирование проверок в следующих заголовках блоков конструкции if_elif_else.
    
    Блоков elif может быть несколько:
    
    if False:
        ...
    elif False:
        ...
    elif True:
        print('Выполняется')
    else:
        print('Игнорируется')
        
  ! if - обязательный блок, elif - опциональный, else - опциональный.
  ! if - независимая условная конструкция 
  
    Одна независимая условная конструкция с зависимыми блоками elif: (зависят от результата предыдущего)
    if 1 == 1: (выполняется проверка)
        ... 
    elif 1 == 2: (игнорируется проверка)
        ...
    elif 1 == 3: (игнорируется проверка)
        ...
    
    Три независимых условных конструкций if: ! теряется производительность
    if 1 == 1: (выполняется проверка)
        ... 
    if 1 == 2: (выполняется проверка)
        ...
    if 1 == 3: (выполняется проверка)
        ...


================================================================================================
        
    
02_05 DRY - Don't Repeat Yourself (Избегай повторов)

    Мы можем объединить несколько выражений при помощи логических операторов
    
    Два бинарных логических оператора (and, or) и один унарный (not)
    
  ! Карточка - Логические операторы (таблица истинности)
  
    False and False - False (логическое 'и')
    False and True  - False
    True and False  - False
    True and True   - True
    
    False or False  - False (логическое 'или')
    False or True   - True
    True or False   - True
    True or True    - True
    
    not False       - True (логическое 'не')
    not True        - False
    
    ПРИМЕР: вместо:
    
        if 1 == 1:
            ...
        elif 1 == 2:
            ...
        
    Используем многосоставное логическое выражение
    
        if 1 == 1 or 1 == 2:
            ...
    
  ! У логических опреаторов and, or, not приоритет ниже, чем у операторов сравнения ==, !=, >, <, >=, <=
    Поэтому сначала выполняются вычисления операторов сравнения и только потом логических операторов
    
    Разбираем частую новичковую ошибку:
    
    if len('text') == 4 or 5: 
    len('text') == 4 (1 выражение), 5 - (2 выражение) - эти выражения не связаны, число 5 приводится к истине:
    
    len('text') == 4 or 5 - длинна текста 4 или 5 - True or 5  -> True
    len('text') == 4 or 0 - длинна текста 4 или 0 - True or 0  -> True
    len('text') == 3 or 5 - длинна текста 0 или 5 - False or 5 -> 5 
    
  ! Логические операторы возвращают не логическое значение объектов, а сами объекты !!!
    Поэтому необходимо явно указывать проверку так:
    
    len('text') == 4 or len('text') == 5
    
    Примеры:
    попадание в диапазон: 
    
        if 0 <= n and n < 10 - два условных выражения (должны выполниться одновременно)
        elif 10 <= n and < 100
        elif 100 <= n and < 1000 
        
    математическая запись двойных неравенств:
    
        if 0 <= n < 1000: синтаксический сахар (тоже самое, что и выражения выше)
    
================================================================================================
    
02_36 - 2. Тернарный (условный) оператор - три операнда

    DEBUG = True
    
    text = input('введите текст: ')
    
    debug_data =  f'{len(text)}\n' if DEBUG else ''
    
    'A' if 1 == 1 else 'B' >>> 'A'
    'A'*3 if 1 == 2 else 'B'*3 >>> 'BBB'
    
================================================================================================

02_47 - Сравнение строк.
    
    Строки сравниваются посимвольно (регистрозависимо)
    
    Лексикографический порядок сравнения. (не тоже самое, что и алфавитный порядок)
    
    'a' == 'A' -> False
    'aa' > 'ab' -> False 
    'd' > 'aa' -> True
    '2' > '11' -> True
    'aa' == 'aaa' -> False
    
  ! Встроенная функция ord('a') - возвращает код символа в кодировочной таблице
    

================================================================================================

Другое полезное
    
   Перегрузка оператора (когда один и тот же оператор с объектами разных типов данных ведет себя по разному).
   Например оператор '+' с объектами int(сложение), с str(конкатенация).
   